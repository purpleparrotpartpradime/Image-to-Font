<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Glyph to Font Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest"></script>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #333;
      margin-top: 10px;
      max-width: 90vw; /* Prevent overflow on smaller screens */
      max-height: 90vh;
    }
    .controls {
      margin-bottom: 20px;
    }
    .visual-overlay {
      position: absolute;
      pointer-events: none;
    }
    #preview-wrapper {
      position: relative;
      display: inline-block;
    }
    input, button {
      margin: 4px;
    }
  </style>
</head>
<body>
  <h1>Glyph to Font Generator</h1>
  <div class="controls">
    <input type="file" accept="image/*" id="imageInput" />
    <input type="text" id="fontName" placeholder="Font Name (e.g. MyFont)" />
    <button onclick="processImage()">Generate Font</button>
    <button id="downloadButton" style="display:none" onclick="downloadFont()">Download TTF</button>
  </div>

  <div id="preview-wrapper">
    <canvas id="canvas"></canvas>
    <canvas id="overlay" class="visual-overlay"></canvas>
  </div>

  <script>
    let canvas = document.getElementById("canvas");
    let overlay = document.getElementById("overlay");
    let ctx = canvas.getContext("2d");
    let overlayCtx = overlay.getContext("2d");
    let imageInput = document.getElementById("imageInput");
    let downloadButton = document.getElementById("downloadButton");
    let fontBlobUrl = null;
    let originalImage = null;

    function processImage() {
      const file = imageInput.files[0];
      if (!file) return alert("No image selected.");

      originalImage = new Image();
      originalImage.onload = () => {
        canvas.width = originalImage.width;
        canvas.height = originalImage.height;
        overlay.width = originalImage.width;
        overlay.height = originalImage.height;
        ctx.drawImage(originalImage, 0, 0);

        // STEP 1: Detect content bounding box and grid
        const bounds = detectContentBounds(canvas);
        const boxes = findBoxes(canvas, bounds);

        // STEP 2: Extract glyphs
        const glyphs = extractGlyphsFromBoxes(canvas, boxes);

        // STEP 3: Generate font
        const font = generateFont(glyphs);

        // STEP 4: Prepare download
        const fontName = document.getElementById("fontName").value || "CustomFont";
        const arrayBuffer = font.toArrayBuffer();
        const blob = new Blob([arrayBuffer], { type: "font/ttf" });
        fontBlobUrl = URL.createObjectURL(blob);
        downloadButton.style.display = "inline-block";
      };
      originalImage.src = URL.createObjectURL(file);
    }

    function downloadFont() {
      if (!fontBlobUrl) return;
      const fontName = document.getElementById("fontName").value || "CustomFont";
      const dl = document.createElement("a");
      dl.href = fontBlobUrl;
      dl.download = fontName + ".ttf";
      document.body.appendChild(dl);
      dl.click();
      document.body.removeChild(dl);
    }

    function detectContentBounds(canvas) {
      const ctx = canvas.getContext("2d");
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;

      // Simple edge detection by scanning for non-background pixels
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const idx = (y * canvas.width + x) * 4;
          const r = imgData.data[idx];
          const g = imgData.data[idx + 1];
          const b = imgData.data[idx + 2];
          const brightness = (r + g + b) / 3;

          if (brightness < 200) { // Assume non-background if not near white
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          }
        }
      }

      // Add padding and ensure bounds are valid
      const padding = 10;
      minX = Math.max(0, minX - padding);
      minY = Math.max(0, minY - padding);
      maxX = Math.min(canvas.width - 1, maxX + padding);
      maxY = Math.min(canvas.height - 1, maxY + padding);

      // Draw bounding box on overlay
      overlayCtx.strokeStyle = "rgba(0, 255, 0, 0.5)";
      overlayCtx.strokeRect(minX, minY, maxX - minX, maxY - minY);

      return { minX, minY, maxX, maxY };
    }

    function findBoxes(canvas, bounds) {
      const gridSize = 6; // 6x6 grid
      const boxes = [];

      const width = bounds.maxX - bounds.minX;
      const height = bounds.maxY - bounds.minY;
      const wStep = width / gridSize;
      const hStep = height / gridSize;

      // Create 6x6 grid within bounds
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const px = bounds.minX + x * wStep;
          const py = bounds.minY + y * hStep;
          const boxW = wStep;
          const boxH = hStep;
          // Draw grid on overlay
          overlayCtx.strokeStyle = "rgba(0, 255, 255, 0.3)";
          overlayCtx.strokeRect(px, py, boxW, boxH);
          boxes.push({ x: px, y: py, w: boxW, h: boxH });
        }
      }
      return boxes;
    }

    function extractGlyphsFromBoxes(canvas, boxes) {
      const ctx = canvas.getContext("2d");
      const glyphs = [];
      let charCode = 65; // 'A'

      boxes.forEach((box, i) => {
        const imgData = ctx.getImageData(box.x, box.y, box.w, box.h);
        const path = new opentype.Path();

        for (let y = 0; y < box.h; y++) {
          for (let x = 0; x < box.w; x++) {
            const idx = (y * box.w + x) * 4;
            const r = imgData.data[idx];
            const g = imgData.data[idx + 1];
            const b = imgData.data[idx + 2];
            const brightness = (r + g + b) / 3;

            if (brightness < 100) {
              const px = (x / box.w) * 600;
              const py = (y / box.h) * 600;
              path.moveTo(px, py);
              path.lineTo(px + 1, py);
              overlayCtx.fillStyle = "rgba(255, 0, 255, 0.5)";
              overlayCtx.fillRect(box.x + x, box.y + y, 1, 1);
            }
          }
        }

        if (path.commands.length > 0) {
          const glyph = new opentype.Glyph({
            name: String.fromCharCode(charCode),
            unicode: charCode,
            advanceWidth: 600,
            path: path
          });
          glyphs.push(glyph);
          charCode++;
        }
      });

      return glyphs;
    }

    function generateFont(glyphs) {
      const fontName = document.getElementById("fontName").value || "CustomFont";
      return new opentype.Font({
        familyName: fontName,
        styleName: "Regular",
        unitsPerEm: 1000,
        ascender: 800,
        descender: -200,
        glyphs: glyphs
      });
    }
  </script>
</body>
</html>
