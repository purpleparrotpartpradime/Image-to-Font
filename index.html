<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Glyph to Font Generator</title>
  <style>
    body { background: black; color: white; font-family: sans-serif; text-align: center; }
    canvas { border: 1px solid #444; margin: 10px 0; }
    #preview { position: relative; display: inline-block; }
    #overlay { position: absolute; left: 0; top: 0; pointer-events: none; }
  </style>
</head>
<body>
  <h1>Glyph to Font Generator</h1>
  <input type="file" accept="image/*" id="fileInput"><br>
  <button onclick="processImage()">Process</button><br>
  <div id="preview">
    <canvas id="canvas"></canvas>
    <canvas id="overlay"></canvas>
  </div>
  <script>
    const canvas = document.getElementById("canvas");
    const overlay = document.getElementById("overlay");
    const ctx = canvas.getContext("2d");
    const octx = overlay.getContext("2d");
    let image;

    function processImage() {
      const file = document.getElementById("fileInput").files[0];
      if (!file) return alert("No file selected.");
      const reader = new FileReader();
      reader.onload = e => {
        image = new Image();
        image.onload = () => {
          canvas.width = image.width;
          canvas.height = image.height;
          overlay.width = image.width;
          overlay.height = image.height;
          ctx.drawImage(image, 0, 0);
          detectDotsAndGrid();
        };
        image.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    async function detectDotsAndGrid() {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const blackPoints = [];

      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const i = (y * canvas.width + x) * 4;
          const [r, g, b] = [data[i], data[i+1], data[i+2]];
          if (r < 50 && g < 50 && b < 50) {
            blackPoints.push({x, y});
          }
        }
      }

      // Naive approach to find 4 extremal dots
      const topLeft = blackPoints.reduce((a, b) => (a.x + a.y < b.x + b.y ? a : b));
      const topRight = blackPoints.reduce((a, b) => (b.x - b.y > a.x - a.y ? b : a));
      const bottomLeft = blackPoints.reduce((a, b) => (b.y - b.x > a.y - a.x ? b : a));
      const bottomRight = blackPoints.reduce((a, b) => (a.x + a.y > b.x + b.y ? a : b));

      octx.clearRect(0, 0, overlay.width, overlay.height);
      [topLeft, topRight, bottomRight, bottomLeft].forEach(p => {
        octx.beginPath();
        octx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
        octx.fillStyle = "red";
        octx.fill();
      });

      // Define grid
      const rows = 6, cols = 6;
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const x = topLeft.x + ((topRight.x - topLeft.x) / cols) * col;
          const y = topLeft.y + ((bottomLeft.y - topLeft.y) / rows) * row;
          const boxWidth = (topRight.x - topLeft.x) / cols;
          const boxHeight = (bottomLeft.y - topLeft.y) / rows;

          octx.strokeStyle = "lime";
          octx.strokeRect(x, y, boxWidth, boxHeight);

          const box = ctx.getImageData(x, y, boxWidth, boxHeight);
          const blob = new Blob([box.data.buffer], {type: 'application/octet-stream'});
          const formData = new FormData();
          const canvasRegion = document.createElement("canvas");
          canvasRegion.width = boxWidth;
          canvasRegion.height = boxHeight;
          canvasRegion.getContext("2d").putImageData(box, 0, 0);
          canvasRegion.toBlob(async blob => {
            formData.append("file", blob, "glyph.png");
            const response = await fetch("/api/ocr", {
              method: "POST",
              body: formData
            });
            const result = await response.json();
            octx.fillStyle = "cyan";
            octx.fillText(result.text || "?", x + 2, y + 12);
          });
        }
      }
    }
  </script>
</body>
</html>
