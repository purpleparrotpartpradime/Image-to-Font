<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Glyph to Font Generator</title>
  <script src="https://cdn.jsdelivr.net/npm/opentype.js@latest"></script>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      border: 1px solid #333;
      margin-top: 10px;
      max-width: 480px;
    }
    .controls {
      margin-bottom: 20px;
    }
    .visual-overlay {
      position: absolute;
      pointer-events: none;
    }
    #preview-wrapper {
      position: relative;
      display: inline-block;
    }
    input, button {
      margin: 4px;
    }
  </style>
</head>
<body>
  <h1>Glyph to Font Generator</h1>
  <div class="controls">
    <input type="file" accept="image/*" id="imageInput" />
    <input type="text" id="fontName" placeholder="Font Name (e.g. MyFont)" />
    <button onclick="processImage()">Generate Font</button>
    <a id="downloadLink" style="display:none" download>Download TTF</a>
  </div>

  <div id="preview-wrapper">
    <canvas id="canvas" width="480" height="480"></canvas>
    <canvas id="overlay" width="480" height="480" class="visual-overlay"></canvas>
  </div>

  <script>
    let canvas = document.getElementById("canvas");
    let overlay = document.getElementById("overlay");
    let ctx = canvas.getContext("2d");
    let overlayCtx = overlay.getContext("2d");
    let imageInput = document.getElementById("imageInput");

    function processImage() {
      const file = imageInput.files[0];
      if (!file) return alert("No image selected.");

      const img = new Image();
      img.onload = async () => {
        canvas.width = img.width;
        canvas.height = img.height;
        overlay.width = img.width;
        overlay.height = img.height;
        ctx.drawImage(img, 0, 0);

        // Clear overlay
        overlayCtx.clearRect(0, 0, overlay.width, overlay.height);

        // STEP 1: Detect corners from 4 dots (for transformation if needed)
        // This can be enhanced with computer vision lib if needed

        // STEP 2: Try to locate grid cells (boxes) using intensity
        const boxes = findBoxes(canvas);

        // STEP 3: Extract glyphs
        const glyphs = extractGlyphsFromBoxes(canvas, boxes);

        // STEP 4: Generate font
        const font = generateFont(glyphs);

        // STEP 5: Download
        const fontName = document.getElementById("fontName").value || "CustomFont";
        const arrayBuffer = font.toArrayBuffer();
        const blob = new Blob([arrayBuffer], { type: "font/ttf" });
        const url = URL.createObjectURL(blob);
        const dl = document.getElementById("downloadLink");
        dl.href = url;
        dl.download = fontName + ".ttf";
        dl.textContent = `Download ${fontName}.ttf`;
        dl.style.display = "inline-block";
      };
      img.src = URL.createObjectURL(file);
    }

    function findBoxes(canvas) {
      // Simplified: naive grid detection
      const gridSize = 6; // 6x6 grid for 36 symbols
      const w = canvas.width / gridSize;
      const h = canvas.height / gridSize;
      let boxes = [];
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const x0 = x * w;
          const y0 = y * h;
          overlayCtx.strokeStyle = "rgba(0, 255, 255, 0.3)";
          overlayCtx.strokeRect(x0, y0, w, h);
          boxes.push({ x: x0, y: y0, w, h });
        }
      }
      return boxes;
    }

    function extractGlyphsFromBoxes(canvas, boxes) {
      const ctx = canvas.getContext("2d");
      const glyphs = [];
      let charCode = 65; // 'A'

      boxes.forEach((box, i) => {
        const imgData = ctx.getImageData(box.x, box.y, box.w, box.h);
        const path = new opentype.Path();

        for (let y = 0; y < box.h; y++) {
          for (let x = 0; x < box.w; x++) {
            const idx = (y * box.w + x) * 4;
            const r = imgData.data[idx];
            const g = imgData.data[idx + 1];
            const b = imgData.data[idx + 2];
            const brightness = (r + g + b) / 3;

            if (brightness < 100) {
              const px = (x / box.w) * 600;
              const py = (y / box.h) * 600;
              path.moveTo(px, py);
              path.lineTo(px + 1, py);
              overlayCtx.fillStyle = "rgba(255, 0, 255, 0.5)";
              overlayCtx.fillRect(box.x + x, box.y + y, 1, 1);
            }
          }
        }

        if (path.commands.length > 0) {
          const glyph = new opentype.Glyph({
            name: String.fromCharCode(charCode),
            unicode: charCode,
            advanceWidth: 600,
            path: path
          });
          glyphs.push(glyph);
          charCode++;
        }
      });

      return glyphs;
    }

    function generateFont(glyphs) {
      const fontName = document.getElementById("fontName").value || "CustomFont";
      return new opentype.Font({
        familyName: fontName,
        styleName: "Regular",
        unitsPerEm: 1000,
        ascender: 800,
        descender: -200,
        glyphs: glyphs
      });
    }
  </script>
</body>
</html>
